from scipy.spatial import Delaunay

def calculate_kriging_variance(wells_df, center_point, radius_km, resolution=50, variogram_model='spherical', use_depth=False, soil_polygons=None):
    """
    Calculate kriging variance for yield or depth to groundwater interpolations.

    This function performs ordinary kriging to estimate the variance (uncertainty)
    of the interpolated values, using Delaunay triangulation for consistent polygon clipping.

    Parameters:
    -----------
    wells_df : DataFrame
        DataFrame containing well data, including latitude, longitude, and
        either yield_rate (for yield interpolation) or depth_to_groundwater/depth
        (for depth interpolation).
    center_point : tuple
        Tuple containing (latitude, longitude) of the center point.
    radius_km : float
        Radius in kilometers to generate the variance data for.
    resolution : int
        Number of points to generate in each dimension.
    variogram_model : str, optional
        Variogram model to use for kriging (e.g., 'linear', 'spherical', 'gaussian').
        Defaults to 'spherical'.
    use_depth : bool
        Whether to use depth data instead of yield data.
    soil_polygons : GeoDataFrame, optional
        Soil polygon data for clipping the variance output.

    Returns:
    --------
    list
        List of [lat, lng, variance] points for the variance heat map.
        Returns an empty list if there is not enough data or if an error occurs.
    """
    try:
        # Filter wells data similar to yield kriging for consistency
        wells_df_filtered = wells_df.copy()
        
        # Determine whether to use yield or depth data based on use_depth parameter
        if use_depth:
            if 'is_dry_well' in wells_df.columns:
                wells_df_filtered = wells_df_filtered[~wells_df_filtered['is_dry_well']]
            
            if 'depth_to_groundwater' in wells_df_filtered.columns and not wells_df_filtered['depth_to_groundwater'].isna().all():
                wells_df_filtered = wells_df_filtered[wells_df_filtered['depth_to_groundwater'].notna() & (wells_df_filtered['depth_to_groundwater'] > 0)]
                values = wells_df_filtered['depth_to_groundwater'].values.astype(float)
                interpolation_type = 'depth_to_groundwater'
            elif 'depth' in wells_df_filtered.columns:
                wells_df_filtered = wells_df_filtered[wells_df_filtered['depth'].notna() & (wells_df_filtered['depth'] > 0)]
                values = wells_df_filtered['depth'].values.astype(float)
                interpolation_type = 'depth'
            else:
                print("Error: No depth data found in wells_df.")
                return []
        else:
            meaningful_yield_mask = wells_df_filtered['yield_rate'].fillna(0) > 0.1
            if meaningful_yield_mask.any() and np.sum(meaningful_yield_mask) >= 5:
                wells_df_filtered = wells_df_filtered[meaningful_yield_mask]
                values = wells_df_filtered['yield_rate'].values.astype(float)
                interpolation_type = 'yield'
            else:
                values = wells_df_filtered['yield_rate'].fillna(0).values.astype(float)
                interpolation_type = 'yield'

        # Ensure there's enough data for kriging
        if len(wells_df_filtered) < 5:
            print("Warning: Insufficient data points for kriging variance calculation after filtering.")
            return []

        # Create grid for interpolation
        center_lat, center_lon = center_point
        grid_size = min(50, max(30, resolution))

        # Convert to km-based coordinates
        km_per_degree_lat = 111.0
        km_per_degree_lon = 111.0 * np.cos(np.radians(center_lat))

        # Convert coordinates to km from center
        lats = wells_df_filtered['latitude'].values.astype(float)
        lons = wells_df_filtered['longitude'].values.astype(float)
        x_coords = (lons - center_lon) * km_per_degree_lon
        y_coords = (lats - center_lat) * km_per_degree_lat

        # Create grid in km space
        grid_x = np.linspace(-radius_km, radius_km, grid_size)
        grid_y = np.linspace(-radius_km, radius_km, grid_size)
        grid_X, grid_Y = np.meshgrid(grid_x, grid_y)

        # Flatten grid for interpolation
        xi = np.vstack([grid_X.flatten(), grid_Y.flatten()]).T
        distances = np.sqrt(xi[:, 0]**2 + xi[:, 1]**2)
        mask = distances <= radius_km
        xi_inside = xi[mask]

        # Convert back to lat/lon for kriging
        lon_values = x_coords / km_per_degree_lon + center_lon
        lat_values = y_coords / km_per_degree_lat + center_lat
        xi_lon = xi_inside[:, 0] / km_per_degree_lon + center_lon
        xi_lat = xi_inside[:, 1] / km_per_degree_lat + center_lat

        # Perform Ordinary Kriging
        OK = OrdinaryKriging(
            lon_values, lat_values, values,
            variogram_model=variogram_model,
            verbose=False,
            enable_plotting=False
        )

        # Execute kriging to get both predictions and variance
        _, kriging_variance = OK.execute('points', xi_lon, xi_lat)

        # Convert grid coordinates back to lat/lon
        grid_lats = (xi_inside[:, 1] / km_per_degree_lat) + center_lat
        grid_lons = (xi_inside[:, 0] / km_per_degree_lon) + center_lon

        # Prepare soil polygon geometry for filtering
        merged_soil_geometry = None
        if soil_polygons is not None and len(soil_polygons) > 0:
            try:
                valid_geometries = [row.geometry for idx, row in soil_polygons.iterrows() if row.geometry and row.geometry.is_valid]
                if valid_geometries:
                    merged_soil_geometry = unary_union(valid_geometries)
                    print(f"Prepared soil drainage geometry for kriging variance filtering")
                else:
                    print("No valid soil polygon geometries found for kriging variance")
            except Exception as e:
                print(f"Error preparing soil polygon geometry for kriging variance: {e}")
                merged_soil_geometry = None

        # Use Delaunay triangulation for consistent clipping
        variance_data = []
        points_2d = np.vstack([grid_lons, grid_lats]).T

        if len(points_2d) > 3:
            tri = Delaunay(points_2d)
            for simplex in tri.simplices:
                vertices = points_2d[simplex]
                vertex_variance = kriging_variance[simplex]
                avg_variance = float(np.mean(vertex_variance))

                # Only include triangles with meaningful variance
                if avg_variance > 0.0001:
                    include_triangle = True
                    if merged_soil_geometry is not None:
                        centroid_lon = float(np.mean(vertices[:, 0]))
                        centroid_lat = float(np.mean(vertices[:, 1]))
                        centroid_point = Point(centroid_lon, centroid_lat)
                        
                        # Strict containment check
                        include_triangle = merged_soil_geometry.contains(centroid_point)
                        if not include_triangle:
                            buffer_distance = 0.0001  # ~10 meters
                            buffered_geometry = merged_soil_geometry.buffer(buffer_distance)
                            include_triangle = buffered_geometry.contains(centroid_point)

                    if include_triangle:
                        # Use centroid for variance data point
                        centroid_lon = float(np.mean(vertices[:, 0]))
                        centroid_lat = float(np.mean(vertices[:, 1]))
                        variance_data.append([
                            centroid_lat,
                            centroid_lon,
                            avg_variance
                        ])
        else:
            print("Warning: Insufficient points for Delaunay triangulation, using raw points")
            for i in range(len(grid_lats)):
                if kriging_variance[i] > 0.0001:
                    include_point = True
                    if merged_soil_geometry is not None:
                        point = Point(grid_lons[i], grid_lats[i])
                        include_point = merged_soil_geometry.contains(point)
                        if not include_point:
                            buffer_distance = 0.0001
                            buffered_geometry = merged_soil_geometry.buffer(buffer_distance)
                            include_point = buffered_geometry.contains(point)
                    
                    if include_point:
                        variance_data.append([
                            float(grid_lats[i]),
                            float(grid_lons[i]),
                            float(kriging_variance[i])
                        ])

        # Log filtering results
        if merged_soil_geometry is not None:
            print(f"Kriging variance filtered by soil drainage areas: {len(variance_data)} points displayed")

        return variance_data

    except Exception as e:
        print(f"Error calculating kriging variance: {e}")
        return []