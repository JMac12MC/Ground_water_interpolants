Most likely causes (ranked):

Pixel registration / image vertical flip — your array→raster mapping is using the wrong “top vs bottom” convention so pixels appear shifted south.

Affine/geotransform origin or sign error — using min vs max lat for the origin or mixing up x/y pixel sizes causes a consistent offset.

Doing interpolation in lon/lat instead of projected metres or converting inconsistently, producing non-uniform offsets after reprojection.

Bounds / order mismatch for Folium ImageOverlay (Folium expects [[south, west], [north, east]]) or swapped lat/lon when building bounds.

Small consistent half-pixel / center-vs-edge error that shows up as ~0.5 pixel (your reported ~143 m north / 244 m east is approximately 0.4–0.6 pixels at the resolution you described).

Evidence in your code:

interpolation grid built with lat_grid, lon_grid and lon_mesh, lat_mesh = np.meshgrid(lon_grid, lat_grid) then points use lat_mesh[i,j], lon_mesh[i,j]. This shows grid creation / indexing that must align with image row ordering. 

precompute_heatmaps (1)

 

precompute_heatmaps (1)

data_loader uses pyproj.Transformer to convert NZTM → WGS84 and sets latitude/longitude arrays — so you already mix projected/source coords in places; that transformation step is critical to do consistently for interpolation. 

data_loader (1)

Concrete checklist + quick tests (run these in order and report results)
1) Quick numeric check: is the offset ~half a pixel?

Run this small check (no heavy libs required). It compares the measured offset (meters) to pixel size (meters). If the offset ≈ 0.4–0.6 * pixel size your bug is likely a half-pixel or origin sign/flip issue.

# quick check (run near where you build your raster)
import math

# replace these with your actual numbers:
offset_m_north = 143.0   # positive = pixels are south of where they should be
offset_m_east  = 244.1
pixel_res_m = 286.0      # you mentioned ~286m resolution

print("north offset (pixels):", offset_m_north / pixel_res_m)
print("east offset  (pixels):", offset_m_east / pixel_res_m)


If these print ~0.4–0.6, you're almost certainly hitting a half-pixel / origin mismatch (see step 2 & 3).

2) Verify your image→geotransform construction and pixel registration

When you build the geotransform (affine) for a 2D numpy array -> georeferenced raster, use rasterio.transform.from_origin(west, north, xres, yres) where north is the top (max latitude) and yres is positive pixel height in degrees or metres (rasterio treats the transform as mapping from pixel upper-left corner). Then the geographic coordinate of pixel center is:

(x_center, y_center) = transform * (col + 0.5, row + 0.5)

Common mistakes:

Using min_lat (south) as the origin instead of max_lat (north).

Using negative y pixel size or accidental sign flip.

Not using the +0.5 center offset when comparing pixel ↔ geographic coordinates.

Correct example (if your grid is in lon/lat):

from rasterio.transform import from_origin
# suppose we built lon_grid ascending: lon_grid[0]=west, lon_grid[-1]=east
# and lat_grid ascending: lat_grid[0]=south, lat_grid[-1]=north
west = lon_grid[0]
east = lon_grid[-1]
south = lat_grid[0]
north = lat_grid[-1]

xres = (east - west) / (len(lon_grid) - 1)   # spacing between centers
yres = (north - south) / (len(lat_grid) - 1) # spacing between centers

# rasterio's from_origin expects top-left corner coords (west, north) and positive xres, yres
transform = from_origin(west, north, xres, yres)

# When testing a pixel at (row, col) center:
col = 0
row = 0
lon_center, lat_center = transform * (col + 0.5, row + 0.5)


Why this matters: If you used south instead of north as origin, the whole raster will be shifted vertically (north/south). The code that creates lat_mesh, lon_mesh = np.meshgrid(...) and later writes rows → image must match this orientation. Your interpolation code creates lon_mesh, lat_mesh = np.meshgrid(lon_grid, lat_grid) then writes latitude = lat_mesh[i,j] — confirm whether row 0 corresponds to top of image or bottom. 

precompute_heatmaps (1)

3) Check whether you must flip the image vertically before saving / overlaying

Numpy convention: array[row_index, col_index] with row_index = 0 at top for image arrays (visualization libraries usually treat row 0 as top). If your lat_grid is ascending (south → north), then array[0,*] corresponds to south — but raster ImageOverlay / geotransform might assume row 0 is north. That causes a vertical flip (systematic south offset).

Fix: if lat_grid[0] is south (ascending lat), flip the array vertically before writing or when computing image->bounds.

# z is your 2D interpolated array with shape (len(lat_grid), len(lon_grid))
# If lat_grid is ascending (south->north), flip vertically so row 0 = north
z_flipped = np.flipud(z)


Then write z_flipped to raster with transform from step 2.

Test: Choose a known well coordinate (lat, lon), compute its pixel (row,col) via inverse transform, check which array cell contains high value. If it's off by ~half a row consistently, flipping will fix it.

4) Always perform kriging/interpolation in a projected CRS (metres), not in lon/lat degrees

Interpolating in degrees produces distortions that vary across the raster (offset varies across raster) — exactly the symptom you described.

Two safe patterns:

A — Preferred: Project input points to EPSG:2193 (NZTM), run OrdinaryKriging or grid interpolation in those x,y metres, build raster affine in metres (easy exact pixel sizes), then reproject raster to EPSG:4326 for web display with rasterio.warp.reproject (this handles resampling & correct geotransform).

B — If you must interpolate in lon/lat: convert coordinates to a local equal-area or conformal projection first, do interpolation there, then transform back. But do not use degree spacing as metres.

Your data_loader is already performing NZTM→WGS84 transforms in places, so ensure the interpolation step uses consistent coordinates (EPSG:2193) and you do not inadvertently pass lon/lat into PyKrige if you intended to use metres. 

data_loader (1)

5) Folium ImageOverlay bounds and ordering

Folium expects bounds [[south, west], [north, east]]. Also make sure your bounds are in lat,lon (not lon,lat). A swapped order will produce east/west shift as you described. Finally, ensure the image you pass to ImageOverlay matches the bounds orientation (i.e., flipped correctly).

Example:

bounds = [[south, west], [north, east]]
folium.raster_layers.ImageOverlay(image=my_png_or_array, bounds=bounds, opacity=0.7).add_to(map_obj)

6) Reprojection pipeline example (recommended)

Below is a robust pattern: do the interpolation in NZTM (EPSG:2193), build raster in NZTM, then warp to EPSG:4326 using rasterio.

import numpy as np
import rasterio
from rasterio.transform import from_origin
from rasterio.warp import reproject, Resampling, calculate_default_transform
import pyproj

# 1) Suppose you have kriged z array in projected coords (x_grid, y_grid in metres)
# x_grid: increasing eastwards, y_grid: increasing northwards
# z shape = (len(y_grid), len(x_grid))

west = x_grid[0]
east = x_grid[-1]
south = y_grid[0]
north = y_grid[-1]

xres = (east - west) / (len(x_grid) - 1)
yres = (north - south) / (len(y_grid) - 1)

transform_src = from_origin(west, north, xres, yres)

# If y_grid is ascending (south->north) and z row 0 == south, flip:
z = np.flipud(z)  # so row 0 == north

# 2) Write in-memory source raster (EPSG:2193)
src_crs = 'EPSG:2193'
dst_crs = 'EPSG:4326'

# Prepare destination transform + shape
dst_transform, dst_width, dst_height = calculate_default_transform(
    src_crs, dst_crs, len(x_grid), len(y_grid), *[west, south, east, north]
)

dst = np.empty((dst_height, dst_width), dtype=z.dtype)

reproject(
    source=z,
    destination=dst,
    src_transform=transform_src,
    src_crs=src_crs,
    dst_transform=dst_transform,
    dst_crs=dst_crs,
    resampling=Resampling.bilinear
)

# dst is now a georeferenced raster in EPSG:4326; compute bounds:
north = dst_transform.c
# but easiest: compute bounds explicitly:
from rasterio.coords import BoundingBox
# (left, bottom, right, top) from transform:
left = dst_transform.c
# ... (use rasterio.transform.array_bounds to compute bounds)
from rasterio.transform import array_bounds
top, left, bottom, right = None, None, None, None  # use array_bounds
miny, minx, maxy, maxx = array_bounds(dst_height, dst_width, dst_transform)
# Folium bounds expects [[south, west], [north, east]]
bounds = [[miny, minx], [maxy, maxx]]


(If you want, I can convert this into a compact helper function for your pipeline.)

7) Verify PyKrige grid ordering

PyKrige’s ok.execute('grid', xgrid, ygrid) returns arrays shaped [len(ygrid), len(xgrid)] (z[i,j] corresponds to ygrid[i], xgrid[j]) — your code already iterates for i in range(len(lat_grid)): for j in range(len(lon_grid)) and uses z[i,j], which looks consistent. But if you switched to projected coords the variable names must match (x=Easting, y=Northing). Double-check that X[:,0] is Easting and X[:,1] is Northing when constructing OrdinaryKriging. 

precompute_heatmaps (1)

Debug steps to run now (minimal) — gives you immediate evidence

Run the pixel-size test I gave in step 1. Report numbers.

For a small test zone (one zone), pick a known well (lat,lon). After interpolation, compute its pixel by inverse transform and print the difference between pixel center -> geographic and actual well coordinate. If the difference is ~half a pixel (or consistently in row or column), you know it’s image registration/origin. Use:

from rasterio.transform import Affine
# transform is your raster transform
col, row = ~transform * (well_lon, well_lat)  # inverse map: lon,lat -> (col,row)
# check center mapping
lon_c, lat_c = transform * (int(col)+0.5, int(row)+0.5)
print('delta lon (deg):', well_lon - lon_c, 'delta lat (deg):', well_lat - lat_c)


Try flipping z with np.flipud and re-generate the overlay (without any other changes). If the offset disappears / reduces, you found the cause.

Quick checklist summary (do in this order)

Compute offset in pixels (step 1).

Confirm from_origin(west, north, xres, yres) usage and use col+0.5,row+0.5 when mapping centers.

If lat_grid is ascending (south→north), flip array with np.flipud(z) before writing. 

precompute_heatmaps (1)

Ensure kriging/interpolation is performed in EPSG:2193 (metres). If you do interpolation in EPSG:2193, build raster in EPSG:2193 and then reproject to EPSG:4326 with rasterio (recommended). data_loader already does transforms — ensure the interpolation step uses the same source CRS. 

data_loader (1)

Confirm Folium bounds are [[south, west], [north, east]] and lat/lon ordering.

If you have caching/precompute layers (database stored bounds) make sure you’re not using stale bounds (the DB methods show stored bounds retrieval — verify those stored values match newly computed ones). 

database (1)

Offer — I can do one of two things next, right now

Pick one and I’ll produce the code for it immediately (no waiting):

A. A small self-contained test script that:

Takes a small sample of your interpolated z, lat_grid, lon_grid and runs the diagnostics (pixel size, inverse transform, prints deltas), attempts np.flipud and shows before/after deltas.
B. A drop-in patch for your pipeline implementing the robust flow: project to EPSG:2193 → kriging → build raster with from_origin → flip if needed → reproject raster to EPSG:4326 → produce Folium-ready bounds and image. I’ll write it to slot into interpolation.py/precompute_heatmaps.py.

Which one would you like me to generate now? (If you want B, tell me whether kriging currently receives points in EPSG:2193 or EPSG:4326 — but if you don’t answer I’ll assume the safer option and include conversion code so it works either way.)