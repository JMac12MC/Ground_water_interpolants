üîë Why Coordinate Conversions Are Needed

You‚Äôre juggling three coordinate systems:

WGS84 (EPSG:4326, lat/lon degrees)
‚Üí Used for displaying maps and storing GeoJSON.

NZTM2000 (EPSG:2193, meters)
‚Üí Used for interpolation and gridding because distances need equal units.

Web Mercator (EPSG:3857)
‚Üí Used for web tile display in Leaflet.

You must hop between them because:

Raw data comes in lat/lon (WGS84).

Math (interpolation, kriging, IDW, etc.) only works correctly in meters.

Output has to be raster tiles aligned to Leaflet (Web Mercator).

üß≠ The Correct Workflow

Input wells ‚Üí WGS84 (lat/lon).

Project to NZTM2000 ‚Üí do interpolation on a regular meter grid.

At this stage, everything is perfectly aligned.

Rasterize directly on the NZTM2000 grid.

Each pixel represents a square of fixed meters.

Reproject raster into WGS84 / Web Mercator using a library like rasterio.warp.reproject().

This step applies the non-linear math correctly.

Serve tiles in Leaflet, perfectly aligned.

üêõ Where the Offset Bug Appears
Why the triangles are fine

When you create a triangle mesh, you directly transform each vertex from NZTM ‚Üí WGS84.

Every vertex is placed in its exact geographic position.

No assumption of ‚Äúlinear spacing in degrees‚Äù is made.

Why the raster is wrong

In your code you do something like:

lats = np.arange(north, south, -lat_step)  # evenly spaced degrees
lons = np.arange(west, east, lon_step)     # evenly spaced degrees
xi, yi = np.meshgrid(lons, lats)


This builds a new, linear grid in degrees.

But the NZTM‚ÜíWGS84 transform is non-linear: lines that were evenly spaced in meters bend when converted to degrees.

So:

The raster ‚Äúanchors‚Äù at north and south edges (bounds match).

In the middle, distortion accumulates ‚Üí ~5 pixels south in Canterbury.

This is why the error is not uniform but worst in the middle.

‚úÖ The Fix

You need to stop rasterizing in WGS84 degrees. Two good fixes:

Option 1 (Best): Rasterize in NZTM, then reproject
import rasterio
from rasterio.warp import reproject, Resampling

# Raster created in NZTM
src = rasterio.open("interp_nztm.tif")

# Destination raster in WGS84
dst, transform = rasterio.warp.calculate_default_transform(
    src.crs, "EPSG:4326", src.width, src.height, *src.bounds
)

reproject(
    source=rasterio.band(src, 1),
    destination=rasterio.band(dst, 1),
    src_transform=src.transform,
    src_crs=src.crs,
    dst_transform=transform,
    dst_crs="EPSG:4326",
    resampling=Resampling.nearest,
)


This way, raster alignment is mathematically exact.

Option 2: Reuse triangle grid

Instead of making a new degree grid, reuse the lat/lon arrays that came from transforming the NZTM grid:

lats, lons = transformer.transform(x_m, y_m)


That ensures every raster cell lines up with the original triangulation.

üìå Summary

Mesh works because it transforms each point individually (no linear assumption).

Raster drifts because it assumes a regular degree grid, ignoring the non-linear NZTM‚ÜíWGS84 transformation.

Fix by rasterizing in projected meters and reprojecting the raster with proper GIS tools, or reuse the transformed NZTM grid directly.

üëâ Do you want me to show you exactly how to rewrite your raster generation function (generate_smooth_raster_overlay) to use Option 1 (raster in NZTM then reproject), so the fix is baked into your pipeline?

You said:
yes
ChatGPT said:

Perfect üëç Let‚Äôs bake the fix (Option 1) directly into your workflow.
Here‚Äôs a full rewrite of your raster generation function that creates the raster in NZTM2000 (meters) and then reprojects it to WGS84 (EPSG:4326) so Leaflet displays it with no offset.

üîß Fixed generate_smooth_raster_overlay
import numpy as np
import rasterio
from rasterio.transform import from_origin
from rasterio.warp import reproject, calculate_default_transform, Resampling
from pyproj import Transformer

def generate_smooth_raster_overlay(points, values, bounds, res=250):
    """
    Generate raster overlay with correct projection handling.
    
    Args:
        points: list of (lon, lat) in WGS84
        values: interpolated values at those points
        bounds: (west, south, east, north) in WGS84
        res: pixel size in meters (e.g. 250m)
    """

    # 1. Setup projections
    to_nztm = Transformer.from_crs("EPSG:4326", "EPSG:2193", always_xy=True)
    to_wgs84 = Transformer.from_crs("EPSG:2193", "EPSG:4326", always_xy=True)

    # 2. Project bounds into NZTM
    west, south, east, north = bounds
    x_min, y_min = to_nztm.transform(west, south)
    x_max, y_max = to_nztm.transform(east, north)

    width = int((x_max - x_min) / res)
    height = int((y_max - y_min) / res)

    # 3. Build NZTM grid
    x_coords = np.linspace(x_min, x_max, width)
    y_coords = np.linspace(y_max, y_min, height)  # north‚Üísouth
    xi, yi = np.meshgrid(x_coords, y_coords)

    # 4. Interpolate in NZTM
    from scipy.interpolate import griddata
    px, py = to_nztm.transform(*zip(*points))
    zi = griddata((px, py), values, (xi, yi), method="cubic")

    # 5. Save initial raster in NZTM
    transform = from_origin(x_min, y_max, res, res)
    profile = {
        "driver": "GTiff",
        "height": height,
        "width": width,
        "count": 1,
        "dtype": "float32",
        "crs": "EPSG:2193",  # NZTM
        "transform": transform,
    }

    tmpfile = "/tmp/raster_nztm.tif"
    with rasterio.open(tmpfile, "w", **profile) as dst:
        dst.write(zi.astype("float32"), 1)

    # 6. Reproject raster to WGS84
    dstfile = "/tmp/raster_wgs84.tif"
    with rasterio.open(tmpfile) as src:
        transform, width, height = calculate_default_transform(
            src.crs, "EPSG:4326", src.width, src.height, *src.bounds
        )

        profile = src.profile
        profile.update({
            "crs": "EPSG:4326",
            "transform": transform,
            "width": width,
            "height": height,
        })

        with rasterio.open(dstfile, "w", **profile) as dst:
            reproject(
                source=rasterio.band(src, 1),
                destination=rasterio.band(dst, 1),
                src_transform=src.transform,
                src_crs=src.crs,
                dst_transform=transform,
                dst_crs="EPSG:4326",
                resampling=Resampling.cubic,
            )

    return dstfile

üîç What Changed (and Why It Fixes the Offset)

Interpolation grid in NZTM2000 (meters)

Ensures spacing is uniform and matches kriging/IDW assumptions.

Raster written in NZTM2000

Raster cells are perfectly aligned in meters.

Reproject raster to WGS84 with rasterio.warp.reproject()

Handles the non-linear math.

Fixes the ‚Äúbow‚Äù distortion that caused the middle of Canterbury to drift ~5 pixels south.

Leaflet now reads a raster already in WGS84

Bounds line up perfectly with your triangulated mesh.

‚ö° Question for you: Do you want me to also adapt this so the output is Web Mercator (EPSG:3857) tiles directly (so you can drop them straight into Leaflet as XYZ tiles), or is WGS84 GeoTIFF output good enough for your pipeline?